# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers 
# and are generated by the following formulae:
#     
# Triangle     	    P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	    P4,n=n2	        	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	    P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	    P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# 
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
# (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# 
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
# triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

CyclicalFigurates <- function() {
    tris <- ShapeSet(Tri)
    sqrs <- ShapeSet(Square)
    pents <- ShapeSet(Pent)
    hexs <- ShapeSet(Hex)
    hepts <- ShapeSet(Hept)
    octs <- ShapeSet(Oct)
    shape.list <- list(octs, hepts, hexs, pents, sqrs, tris)
    all <- unique(unlist(shape.list))
    sets <- list()
    for (a in all) {
        for (b in all[floor(all/100)==a%%100]) {
            for (c in all[floor(all/100)==b%%100]) {
                for (d in all[floor(all/100)==c%%100]) {
                    for (e in all[floor(all/100)==d%%100]) {
                        for (f in all[floor(all/100)==e%%100]) {
                            set <- c(a,b,c,d,e,f)
                            sets[[length(sets)+1]] <- set
                        }
                    }
                } 
            }
        }
    }
    uniqued <- lapply(sets, unique)
    full.sets <- uniqued[sapply(uniqued, function(x) length(x)==6)]
    cyclical <- full.sets[sapply(full.sets, function(x) floor(x[1]/100)==x[6]%%100)]
    shapes <- lapply(cyclical, function(x) sapply(x, Shapes, shape.list))
    full.shapes <- FullShapes(shapes) # return indices of shapes with all shapes represented by a different n
    sum(cyclical[[full.shapes[1]]])
}

FullShapes <- function(shapes) {
    completes <- c()
    for (i in 1:length(shapes)) {
        shape <- shapes[[i]]
        for (a in shape[[1]]) {
            for (b in shape[[2]]) {
                for (c in shape[[3]]) {
                    for (d in shape[[4]]) {
                        for (e in shape[[5]]) {
                            for (f in shape[[6]]) {
                                chk <- c(a,b,c,d,e,f)
                                if (identical(sort(chk),1:6)) completes <- c(completes, i)
                            }
                        }
                    }
                }
            }
        }
    }
    completes
}

Shapes <- function(n, shape.list) {
    which(sapply(shape.list, function(x) n %in% x))
}

ShapeSet <- function(FUN) {
    n <- 1
    x <- FUN(n)
    set <- c()
    while (x<10000) {
        if (nchar(x)==4 && substr(x,3,3)!="0") set <- c(set, x)
        n <- n+1
        x <- FUN(n)
    }
    set
}

Tri <- function(n) (n^2+n)/2    
Square <- function(n) n^2
Pent <- function(n) (3*n^2-n)/2
Hex <- function(n) 2*n^2-n
Hept <- function(n) (5*n^2-3*n)/2
Oct <- function(n) 3*n^2-2*n

#a <- CyclicalFigurates()

# Unit: seconds
# expr      min       lq     mean   median       uq      max neval
# CyclicalFigurates() 18.78219 18.78219 18.78219 18.78219 18.78219 18.78219     1
